# 用户隔离功能安全优化总结

## 1. 🔐 安全问题分析

### 1.1 ❌ 原有方案的安全隐患

**问题1：用户可以伪造身份查看其他人的数据**
```javascript
// 攻击者可以在浏览器控制台执行：
localStorage.setItem('userId', '3');  // 伪装成用户ID=3
// 然后刷新页面，就能看到用户3的所有数据
```

**问题2：用户可以修改请求参数窃取数据**
```javascript
// 攻击者可以在浏览器开发者工具修改请求：
GET /api/tasks?user_id=1  // 查看用户1的任务
GET /api/tasks?user_id=2  // 查看用户2的任务
```

**问题3：用户可以创建数据到其他人名下**
```javascript
// 攻击者创建任务时指定别人的ID：
{
  "task_name": "恶意任务",
  "user_id": 3  // 让系统认为是用户3创建的
}
```

### 1.2 🔴 为什么原有方案不安全？

原有方案的核心问题：**后端信任前端传递的用户ID**

```python
# ❌ 不安全的做法
@task_bp.route('/tasks', methods=['GET'])
def get_tasks():
    user_id = request.args.get('user_id')  # 从请求参数获取
    tasks = TaskInfo.query.filter_by(user_id=int(user_id)).all()
    return jsonify(tasks)
```

前端可以随意修改 `user_id` 参数，后端无法验证真实性！

---

## 2. ✅ JWT 认证方案（已实现）

### 2.1 核心原理

1. **登录时生成 Token**
   - 用户登录成功后，后端生成包含用户信息的 JWT token
   - Token 使用密钥签名，前端无法伪造

2. **请求时验证 Token**
   - 前端每次请求时携带 token
   - 后端验证 token 的签名和有效期
   - 从 token 中提取用户ID，**不再信任前端参数**

3. **权限控制**
   - 普通用户只能操作自己的数据
   - 管理员可以查看和管理所有数据

---

## 3. 📋 实现步骤

### 3.1 后端实现

#### 3.1.1 安装依赖
```bash
pip install PyJWT==2.8.0
```

#### 3.1.2 创建 JWT 工具函数
**文件：`backend/utils/jwt_utils.py`**
```python
import jwt
from datetime import datetime, timedelta
from functools import wraps
from flask import request, jsonify

SECRET_KEY = 'your-secret-key-change-in-production'
ALGORITHM = 'HS256'
TOKEN_EXPIRATION_HOURS = 24

def generate_token(user_id: int, username: str, role: str) -> str:
    """生成 JWT token"""
    payload = {
        'user_id': user_id,
        'username': username,
        'role': role,
        'exp': datetime.utcnow() + timedelta(hours=TOKEN_EXPIRATION_HOURS),
        'iat': datetime.utcnow()
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

def verify_token(token: str) -> dict:
    """验证 JWT token"""
    try:
        return jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
    except jwt.ExpiredSignatureError:
        raise jwt.ExpiredSignatureError('Token已过期，请重新登录')
    except jwt.InvalidTokenError:
        raise jwt.InvalidTokenError('Token无效')

def token_required(f):
    """装饰器：要求请求必须携带有效的 token"""
    @wraps(f)
    def decorated(*args, **kwargs):
        token = None
        
        # 从请求头获取 token
        if 'Authorization' in request.headers:
            auth_header = request.headers['Authorization']
            try:
                token = auth_header.split(' ')[1]  # 格式：Bearer <token>
            except IndexError:
                return jsonify({'code': 401, 'message': 'Token格式错误'}), 401
        
        if not token:
            return jsonify({'code': 401, 'message': '未提供Token，请先登录'}), 401
        
        try:
            current_user = verify_token(token)
            return f(current_user, *args, **kwargs)
        except jwt.ExpiredSignatureError:
            return jsonify({'code': 401, 'message': 'Token已过期，请重新登录'}), 401
        except jwt.InvalidTokenError:
            return jsonify({'code': 401, 'message': 'Token无效'}), 401
    
    return decorated
```

#### 3.1.3 更新登录接口
**文件：`backend/controllers/auth_controller.py`**
```python
from utils.jwt_utils import generate_token

@auth_bp.route('/login', methods=['POST'])
def login():
    # ... 验证用户名密码 ...
    
    # ✅ 生成 JWT token
    token = generate_token(user.id, user.name, user.role)
    
    return jsonify({
        'code': 200,
        'message': '登录成功',
        'data': {
            'id': user.id,
            'username': user.name,
            'role': user.role,
            'token': token  # 返回 token
        }
    })
```

#### 3.1.4 更新任务接口（使用 JWT 认证）
**文件：`backend/controllers/task_controller.py`**
```python
from utils.jwt_utils import token_required

@task_bp.route('/tasks', methods=['GET'])
@token_required  # ← 添加认证装饰器
def get_tasks(current_user):  # ← 自动注入 current_user
    # ✅ 从 token 中获取用户ID（安全，无法伪造）
    user_id = current_user['user_id']
    user_role = current_user['role']
    
    # 管理员可以查看所有任务
    if user_role in ['super_admin', '管理员']:
        tasks = TaskInfo.query.all()
    else:
        # 普通用户只能查看自己的任务
        tasks = TaskInfo.query.filter_by(user_id=user_id).all()
    
    return jsonify({...})

@task_bp.route('/tasks', methods=['POST'])
@token_required
def create_task(current_user):
    # ✅ 使用 token 中的用户ID，忽略前端传递的参数
    user_id = current_user['user_id']
    
    new_task = TaskInfo(
        task_name=data.get('task_name'),
        user_id=user_id  # 强制使用 token 中的用户ID
    )
    # ...

@task_bp.route('/tasks/<task_name>', methods=['PUT'])
@token_required
def update_task(current_user, task_name):
    task = db.session.get(TaskInfo, decoded_name)
    
    # ✅ 权限验证：只能修改自己的任务
    if task.user_id != current_user['user_id'] and current_user['role'] not in ['super_admin', '管理员']:
        return jsonify({'code': 403, 'message': '无权修改其他用户的任务'}), 403
    
    # ...
```

#### 3.1.5 更新检查记录接口（使用 JWT 认证）
**文件：`backend/controllers/inspection_controller.py`**
```python
from utils.jwt_utils import token_required

@inspection_bp.route('/inspections/task/<task_name>', methods=['GET'])
@token_required
def get_inspection_by_task(current_user, task_name):
    # ✅ 验证权限
    if inspection.user_id != current_user['user_id'] and current_user['role'] not in ['super_admin', '管理员']:
        return jsonify({'code': 403, 'message': '无权查看其他用户的检查记录'}), 403
    # ...

@inspection_bp.route('/inspections/<task_name>', methods=['PUT'])
@token_required
def update_inspection(current_user, task_name):
    # ✅ 验证权限
    if inspection.user_id != current_user['user_id'] and current_user['role'] not in ['super_admin', '管理员']:
        return jsonify({'code': 403, 'message': '无权修改其他用户的检查记录'}), 403
    # ...
```

### 3.2 前端实现

#### 3.2.1 更新请求拦截器（自动携带 token）
**文件：`src/utils/request.ts`**
```typescript
service.interceptors.request.use(
    (config: InternalAxiosRequestConfig) => {
        // ✅ 自动添加 token 到请求头
        const token = localStorage.getItem('token');
        if (token && config.headers) {
            config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
    },
    // ...
);

service.interceptors.response.use(
    // ...
    (error: AxiosError) => {
        // ✅ 处理 token 过期
        if (error.response?.status === 401) {
            localStorage.removeItem('token');
            localStorage.removeItem('userId');
            window.location.href = '/#/login';
        }
        return Promise.reject(error);
    }
);
```

#### 3.2.2 登录时保存 token
**文件：`src/views/pages/login.vue`**
```typescript
if (res.data.code === 200) {
    const userData = res.data.data;
    localStorage.setItem('token', userData.token);  // ✅ 保存 token
    localStorage.setItem('userId', userData.id);
    // ...
}
```

#### 3.2.3 移除前端的 user_id 参数
**文件：`src/views/VoyageInfo/task-manage.vue`**
```typescript
// ❌ 原有代码（不安全）
const getData = async () => {
    const userId = localStorage.getItem('userId');
    const res = await fetchTasksNew({ user_id: userId });  // 前端传递 user_id
    // ...
};

// ✅ 新代码（安全）
const getData = async () => {
    // 不再传递 user_id，后端会从 token 中获取
    const res = await fetchTasksNew({});
    // ...
};
```

---

## 4. 🔒 安全对比

### 4.1 原有方案（不安全）
```
┌─────────┐                    ┌─────────┐
│  前端   │ user_id=1 (可伪造) │  后端   │
│         ├───────────────────>│         │
│         │                    │ 信任前端│
└─────────┘                    └─────────┘
           ❌ 用户可以修改 user_id
```

### 4.2 JWT 方案（安全）
```
┌─────────┐                    ┌─────────┐
│  前端   │  Token (已签名)    │  后端   │
│         ├───────────────────>│         │
│         │                    │ 验证签名│
│         │                    │ 提取ID  │
└─────────┘                    └─────────┘
           ✅ Token 无法伪造，后端不信任前端参数
```

---

## 5. 🚀 使用指南

### 5.1 安装依赖
```bash
cd backend
pip install -r requirements.txt
```

### 5.2 重启后端
```bash
python app.py
```

### 3. 测试登录
```bash
curl -X POST http://localhost:5000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"123","password":"123456"}'

# 返回：
{
  "code": 200,
  "data": {
    "id": 3,
    "username": "123",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

### 4. 使用 token 访问接口
```bash
# ✅ 正确方式（携带 token）
curl http://localhost:5000/api/tasks \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# ❌ 错误方式（不携带 token）
curl http://localhost:5000/api/tasks
# 返回：{"code": 401, "message": "未提供Token，请先登录"}

# ❌ 伪造 user_id（无效）
curl http://localhost:5000/api/tasks?user_id=999 \
  -H "Authorization: Bearer <token>"
# 后端会忽略 user_id 参数，使用 token 中的真实用户ID
```

---

## 🎯 安全改进总结

### ✅ 解决的安全问题

1. **防止身份伪造**：用户无法通过修改 localStorage 伪装成其他用户
2. **防止参数篡改**：用户无法通过修改请求参数访问其他用户的数据
3. **防止数据归属篡改**：用户无法创建数据到其他用户名下
4. **自动过期机制**：Token 24小时自动过期，需要重新登录
5. **权限控制**：普通用户只能操作自己的数据，管理员可以管理所有数据

### 🔒 安全特性

- ✅ **Token 签名验证**：后端使用密钥签名，前端无法伪造
- ✅ **自动过期**：Token 24小时后自动失效
- ✅ **不信任前端**：后端完全忽略前端传递的 user_id，只从 token 中提取
- ✅ **权限验证**：每个操作都会验证用户是否有权限
- ✅ **统一认证**：所有接口统一使用 `@token_required` 装饰器

### 📈 进一步优化建议

1. **使用环境变量存储密钥**
   ```python
   import os
   SECRET_KEY = os.environ.get('JWT_SECRET_KEY', 'default-key')
   ```

2. **实现 Token 刷新机制**
   - 当 token 快过期时自动刷新
   - 避免用户频繁登录

3. **记录操作日志**
   - 记录谁、什么时候、做了什么操作
   - 便于审计和追溯

4. **IP 白名单**
   - 限制只能从特定 IP 访问敏感接口

5. **密码加密**
   - 使用 bcrypt 或 argon2 加密存储密码
   - 当前密码是明文存储，不安全

---

**更新时间**：2025年10月1日  
**安全级别**：✅ 高（已实现 JWT 认证）  
**测试状态**：✅ 后端已实现，前端已适配  
**下一步**：实现 token 刷新机制、密码加密

