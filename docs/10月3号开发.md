## 10月3号开发

本文记录 10 月 3 日当日开发与修复内容，包含：联查两个设备表的数据聚合、筛选与分页恢复、三个模块的前端 Excel 导出实现、导致“只显示一行”的根因分析与修复、表格横向滚动与固定操作列的处理方法，以及一个示例级的 Python/SQLAlchemy 建表脚本讲解，便于在其它机器快速复刻环境。

---

### 一、后端：仪器设备管理 联查两个表（tb_equipment + tb_voyage_equipment）

目标：按 `user_id` 聚合“航前”和“航中”的仪器设备，统一返回列表，并支持筛选与分页。

关键片段（节选，自 `backend/controllers/equipment_management_controller.py`）：

```python
# 读取分页与筛选参数
page = int(request.args.get('page', 1))
page_size = int(request.args.get('page_size', 10))
task_name = request.args.get('task_name', '').strip()
instrument_type = request.args.get('instrument_type', '').strip()
instrument_name = request.args.get('instrument_name', '').strip()
traceability = request.args.get('traceability', '').strip()
calibration_institution = request.args.get('calibration_institution', '').strip()

# 使用 UNION ALL 直接联查两个表（均按 user_id 过滤）
sql = """
SELECT 
    'pre_voyage' as source_type,
    id,
    task_name,
    category,
    name as instrument_name,
    number as instrument_number,
    model,
    traceability_method,
    calibration_date,
    certificate_number,
    validity_period,
    calibration_organization as calibration_institution,
    remarks,
    attachments,
    user_id,
    create_time,
    update_time
FROM tb_equipment 
WHERE user_id = :user_id

UNION ALL

SELECT 
    'during_voyage' as source_type,
    id,
    task_name,
    category,
    name as instrument_name,
    number as instrument_number,
    model,
    traceability_method,
    calibration_date,
    certificate_number,
    validity_period,
    calibration_organization as calibration_institution,
    remarks,
    attachments,
    user_id,
    create_time,
    update_time
FROM tb_voyage_equipment 
WHERE user_id = :user_id
"""

result = db.session.execute(text(sql), {'user_id': user_id}).fetchall()

# 注意：循环中不要使用与“筛选参数”同名的局部变量（否则会覆盖外层查询条件）
all_equipment_list = []
for row in result:
    row_instrument_name = getattr(row, 'instrument_name', '')
    row_instrument_number = getattr(row, 'instrument_number', '')

    all_equipment_list.append({
        'id': row.id,
        'task_name': row.task_name,
        'category': row.category,
        'instrument_name': row_instrument_name,
        'instrument_number': row_instrument_number,
        'model': row.model,
        'traceability_method': row.traceability_method,
        'calibration_date': str(row.calibration_date) if row.calibration_date else None,
        'certificate_number': row.certificate_number,
        'validity_period': row.validity_period,
        'calibration_institution': row.calibration_institution,
        'remarks': row.remarks,
        'attachments': row.attachments,
        'user_id': row.user_id,
        'create_time': str(row.create_time) if row.create_time else None,
        'update_time': str(row.update_time) if row.update_time else None,
        'source_type': '航前' if row.source_type == 'pre_voyage' else '航中'
    })

# 应用筛选（全部在 Python 侧进行，保证语义一致）
filtered_list = all_equipment_list
if task_name:
    filtered_list = [e for e in filtered_list if task_name.lower() in e['task_name'].lower()]
if instrument_type:
    filtered_list = [e for e in filtered_list if instrument_type.lower() in e['category'].lower()]
if instrument_name:
    filtered_list = [e for e in filtered_list if instrument_name.lower() in e['instrument_name'].lower()]
if traceability:
    filtered_list = [e for e in filtered_list if traceability.lower() in (e['traceability_method'] or '').lower()]
if calibration_institution:
    filtered_list = [e for e in filtered_list if calibration_institution.lower() in (e['calibration_institution'] or '').lower()]

# 分页
total = len(filtered_list)
start_index = (page - 1) * page_size
end_index = start_index + page_size
equipment_list = filtered_list[start_index:end_index]
```

逐行说明：
- 读取 `page/page_size` 与各筛选参数；统一 `.strip()`，避免传入空格导致命中失败。
- 使用一段 `UNION ALL` SQL 联查两个表，并统一字段别名（如 `name -> instrument_name`），全部按 `user_id` 过滤，确保数据隔离。
- 查询后在 Python 里构建字典列表；特别注意：循环内使用 `row_instrument_name` 等变量名，避免覆盖外层同名的“筛选参数”。此前“只显示一条”的根因即为变量名覆盖导致再次被误筛选。
- 所有筛选在 Python 侧进行，语义与前端表单 1:1，对空值做兼容。
- 分页采用切片方式，返回 `list` 与 `total`。

---

### 二、前端：三个模块的 Excel 导出

#### 2.1 仪器设备管理（`src/views/system/equipment-management.vue`）

核心做法：
- 导出时重新以大页容量拉取一次数据（`page=1, page_size=100000`），确保“导出全部符合筛选条件的数据”，不受可视分页影响。
- 使用 `xlsx` 将 JSON 转为表格并保存。

代码片段：

```ts
import * as XLSX from 'xlsx'

const handleExport = async () => {
  const params = {
    page: 1,
    page_size: 100000,
    task_name: filterForm.task_name,
    instrument_type: filterForm.instrument_type,
    instrument_name: filterForm.instrument_name,
    traceability: filterForm.traceability,
    calibration_institution: filterForm.calibration_institution
  }

  const res = await fetchEquipmentManagementList(params)
  const rows = (res.data.list || []).map(row => ({
    '航次名称': row.task_name,
    '类别': row.category,
    '仪器(标准物质)名称': row.instrument_name,
    '编号': row.instrument_number,
    '型号': row.model,
    '量值溯源方式': row.traceability_method,
    '检定/校准日期': row.calibration_date,
    '证书编号': row.certificate_number,
    '有效期': row.validity_period,
    '检定/校准机构': row.calibration_institution,
    '备注': row.remarks,
    '数据来源': row.source_type
  }))

  const wb = XLSX.utils.book_new()
  const ws = XLSX.utils.json_to_sheet(rows)
  XLSX.utils.book_append_sheet(wb, ws, '仪器设备管理')
  XLSX.writeFile(wb, `仪器设备管理_${Date.now()}.xlsx`)
}
```

同理，已对“调查人员”（`investigation-personnel.vue`）与“任务单位”（`task-unit.vue`）分别实现同样的导出逻辑，只是字段映射不同。

#### 2.2 关键点
- 采用“再次请求 + 大分页”的方式导出，避免与页面分页耦合。
- 使用 `xlsx` 的 `json_to_sheet` 直接生成表格，简单稳定。
- 文件命名带上时间戳，防止覆盖。

---

### 三、表格横向滚动与固定操作列

目标：当列较多时，表格在宽度不足时出现横向滚动，且“操作”列固定于右侧。

实现要点：
- 为列提供合理的 `width`/`min-width`，总宽度超过容器触发横向滚动。
- 外层容器保持默认（Element Plus 会自动在列总宽超出时出现横向滚动）。
- 操作列使用 `fixed="right"` 固定。

参考（Element Plus 表格列配置）：

```vue
<el-table :data="tableData" border stripe>
  <el-table-column prop="task_name" label="航次名称" min-width="200" />
  <el-table-column prop="instrument_name" label="仪器名称" min-width="200" />
  <el-table-column prop="model" label="型号" width="120" />
  <!-- 其它列 ... -->
  <el-table-column label="操作" width="160" fixed="right" />
</el-table>
```

如需进一步“变窄行”的视觉表现，可在单元格内文本超长时使用省略样式：

```css
/* 仅示例，可按需放到 scoped 样式中 */
.ellipsis-cell {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

---

### 四、根因修复：为什么“只有一行数据”

现象：接口 200，但前端只看到 1 行。禁用分页后又能看到全部。

根因：后端在“构建行字典”的循环中使用了与筛选参数相同的变量名（例如 `instrument_name`），导致外层的“查询条件”被最后一条记录覆盖；随后又按这个被覆盖的条件进行二次过滤，自然只剩下符合“最后一条记录名称”的一行。

修复：将循环内字段改名（如 `row_instrument_name`），彻底避开与筛选参数同名。此后恢复了正常的筛选与分页，数据条数正确。

---

### 五、数据库建表脚本（示例，SQLAlchemy）

以下示例展示如何用 SQLAlchemy 定义并创建 `tb_equipment` 与 `tb_voyage_equipment` 两张表（与当前项目字段保持一致）：

```python
from datetime import datetime
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://user:pwd@127.0.0.1:3306/marine_survey_db?charset=utf8mb4'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    db.init_app(app)
    return app

class Equipment(db.Model):
    __tablename__ = 'tb_equipment'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    task_name = db.Column(db.String(255), nullable=False)
    category = db.Column(db.String(100), nullable=False)
    name = db.Column(db.String(255), nullable=False)
    number = db.Column(db.String(100), nullable=False)
    model = db.Column(db.String(100), nullable=False)
    traceability_method = db.Column(db.String(255))
    calibration_date = db.Column(db.String(45))
    certificate_number = db.Column(db.String(100))
    validity_period = db.Column(db.String(45))
    calibration_organization = db.Column(db.String(255))
    remarks = db.Column(db.Text)
    attachments = db.Column(db.Text)
    user_id = db.Column(db.Integer, nullable=False)
    create_time = db.Column(db.DateTime, default=datetime.now)
    update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)

class VoyageEquipment(db.Model):
    __tablename__ = 'tb_voyage_equipment'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    task_name = db.Column(db.String(255), nullable=False)
    category = db.Column(db.String(100), nullable=False)
    name = db.Column(db.String(255), nullable=False)
    number = db.Column(db.String(100), nullable=False)
    model = db.Column(db.String(100), nullable=False)
    traceability_method = db.Column(db.String(255))
    calibration_date = db.Column(db.String(45))
    certificate_number = db.Column(db.String(100))
    validity_period = db.Column(db.String(45))
    calibration_organization = db.Column(db.String(255))
    remarks = db.Column(db.Text)
    attachments = db.Column(db.Text)
    user_id = db.Column(db.Integer, nullable=False)
    create_time = db.Column(db.DateTime, default=datetime.now)
    update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)

if __name__ == '__main__':
    app = create_app()
    with app.app_context():
        db.create_all()  # 第一次执行会在数据库中创建两张表
        print('tables created')
```

逐行要点：
- 统一使用 `name/number/traceability_method` 字段，与实际表结构一致，避免列名不匹配。
- 采用 `db.create_all()` 在首次部署时创建表结构；生产环境建议使用迁移工具（如 Alembic）进行版本化管理。

---

### 六、用户个人管理模块开发

#### 6.1 需求分析
用户点击"用户管理"菜单时，应该跳转到个人管理页面，而不是任务管理页面。用户只能查看和修改自己的信息，包括修改密码。

#### 6.2 后端实现

**6.2.1 数据库模型扩展**
在 `backend/models/user.py` 中添加 `email` 和 `phone` 字段：

```python
class User(db.Model):
    # ... 其他字段
    email = db.Column(db.String(100))
    phone = db.Column(db.String(20))
    
    def to_dict(self):
        return {
            # ... 其他字段
            'email': self.email,
            'phone': self.phone
        }
```

**6.2.2 密码加密工具**
在 `backend/utils/jwt_utils.py` 中添加密码加密和验证函数：

```python
import hashlib

def hash_password(password: str) -> str:
    """对密码进行MD5哈希加密"""
    return hashlib.md5(password.encode('utf-8')).hexdigest()

def verify_password(password: str, hashed_password: str) -> bool:
    """验证密码是否正确"""
    return hash_password(password) == hashed_password
```

**6.2.3 API接口实现**
在 `backend/controllers/user_controller.py` 中添加三个新接口：

```python
@user_bp.route('/user/profile', methods=['GET'])
@token_required
def get_current_user_profile(current_user):
    """获取当前用户信息（不返回密码）"""
    user_id = current_user['user_id']
    user = User.query.filter_by(id=user_id).first()
    user_data = user.to_dict()
    user_data.pop('password', None)  # 移除密码字段
    return jsonify({'code': 200, 'data': user_data})

@user_bp.route('/user/profile', methods=['PUT'])
@token_required
def update_current_user_profile(current_user):
    """更新当前用户信息（只允许更新特定字段）"""
    user_id = current_user['user_id']
    user = User.query.filter_by(id=user_id).first()
    data = request.json
    
    # 只允许更新这些字段
    allowed_fields = ['sex', 'department', 'email', 'phone']
    for key, value in data.items():
        if key in allowed_fields and hasattr(user, key):
            setattr(user, key, value)
    
    db.session.commit()
    return jsonify({'code': 200, 'message': '更新成功'})

@user_bp.route('/user/change-password', methods=['PUT'])
@token_required
def change_password(current_user):
    """修改密码（需要验证当前密码）"""
    user_id = current_user['user_id']
    user = User.query.filter_by(id=user_id).first()
    data = request.json
    
    current_password = data.get('currentPassword')
    new_password = data.get('newPassword')
    
    # 验证当前密码
    if not verify_password(current_password, user.password):
        return jsonify({'code': 400, 'message': '当前密码错误'}), 400
    
    # 更新密码
    user.password = hash_password(new_password)
    db.session.commit()
    return jsonify({'code': 200, 'message': '密码修改成功'})
```

#### 6.3 前端实现

**6.3.1 路由配置**
在 `src/router/index.ts` 中添加用户个人管理路由：

```typescript
{
    path: '/user-profile',
    name: 'user-profile',
    meta: {
        title: '个人信息管理',
        permiss: '0',  // 所有用户都可以访问
    },
    component: () => import('../views/system/user-profile.vue'),
}
```

**6.3.2 菜单配置**
在 `src/components/menu.ts` 中修改用户管理菜单指向：

```typescript
{
    id: '11',
    pid: '1',
    index: '/user-profile',  // 从 '/system-user' 改为 '/user-profile'
    title: '用户管理',
}
```

**6.3.3 API服务**
创建 `src/api/user-profile.ts`：

```typescript
import request from '../utils/request';

export const getCurrentUserProfile = () => {
    return request({ url: '/user/profile', method: 'get' });
};

export const updateCurrentUserProfile = (data: any) => {
    return request({ url: '/user/profile', method: 'put', data });
};

export const changePassword = (data: any) => {
    return request({ url: '/user/change-password', method: 'put', data });
};
```

**6.3.4 用户界面组件**
创建 `src/views/system/user-profile.vue`，包含：

- **个人信息表单**：用户名、登录名（只读）、性别、部门、角色（只读）、邮箱、电话
- **密码修改表单**：当前密码、新密码、确认密码
- **表单验证**：邮箱格式、手机号格式、密码长度、密码确认
- **安全特性**：修改密码后自动跳转登录页

#### 6.4 数据库迁移
创建 `backend/add_user_fields.py` 脚本，自动添加 `email` 和 `phone` 字段：

```python
# 检查并添加email字段
db.session.execute(text("ALTER TABLE tb_user ADD COLUMN email VARCHAR(100)"))

# 检查并添加phone字段  
db.session.execute(text("ALTER TABLE tb_user ADD COLUMN phone VARCHAR(20)"))
```

#### 6.5 安全特性
- **JWT认证**：所有接口都需要有效的JWT token
- **用户隔离**：用户只能访问和修改自己的信息
- **密码验证**：修改密码需要验证当前密码
- **字段限制**：只允许更新特定字段（sex, department, email, phone）
- **自动登出**：密码修改成功后自动清除token并跳转登录页

---

### 七、今日完成清单
- 修复"仪器设备管理"只显示一条数据：变量名覆盖筛选条件 → 已改名避冲突。
- 恢复并稳定筛选与分页逻辑（服务端筛选 + 切片分页）。
- 新增三处导出：
  - 仪器设备管理 导出 Excel
  - 调查人员 导出 Excel
  - 任务单位 导出 Excel
- 规范联查：使用 `UNION ALL`，并在 Python 侧统一字段名、进行筛选与分页。
- 表格横向滚动行为与操作列固定说明，提供可复用配置。
- **新增用户个人管理模块**：
  - 创建用户个人管理页面（只允许用户管理自己的信息）
  - 实现修改密码功能（需要验证当前密码）
  - 实现用户信息编辑功能（限制可编辑字段）
  - 修改路由和菜单配置，让用户管理指向个人管理页面
  - 添加数据库字段迁移脚本

---

如需将本说明同步为英文或补充其它模块的导出/导入脚本，请在任务单中补充要求。


