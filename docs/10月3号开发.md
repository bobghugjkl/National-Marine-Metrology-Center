## 10月3号开发

本文记录 10 月 3 日当日开发与修复内容，包含：联查两个设备表的数据聚合、筛选与分页恢复、三个模块的前端 Excel 导出实现、导致“只显示一行”的根因分析与修复、表格横向滚动与固定操作列的处理方法，以及一个示例级的 Python/SQLAlchemy 建表脚本讲解，便于在其它机器快速复刻环境。

---

### 一、后端：仪器设备管理 联查两个表（tb_equipment + tb_voyage_equipment）

目标：按 `user_id` 聚合“航前”和“航中”的仪器设备，统一返回列表，并支持筛选与分页。

关键片段（节选，自 `backend/controllers/equipment_management_controller.py`）：

```python
# 读取分页与筛选参数
page = int(request.args.get('page', 1))
page_size = int(request.args.get('page_size', 10))
task_name = request.args.get('task_name', '').strip()
instrument_type = request.args.get('instrument_type', '').strip()
instrument_name = request.args.get('instrument_name', '').strip()
traceability = request.args.get('traceability', '').strip()
calibration_institution = request.args.get('calibration_institution', '').strip()

# 使用 UNION ALL 直接联查两个表（均按 user_id 过滤）
sql = """
SELECT 
    'pre_voyage' as source_type,
    id,
    task_name,
    category,
    name as instrument_name,
    number as instrument_number,
    model,
    traceability_method,
    calibration_date,
    certificate_number,
    validity_period,
    calibration_organization as calibration_institution,
    remarks,
    attachments,
    user_id,
    create_time,
    update_time
FROM tb_equipment 
WHERE user_id = :user_id

UNION ALL

SELECT 
    'during_voyage' as source_type,
    id,
    task_name,
    category,
    name as instrument_name,
    number as instrument_number,
    model,
    traceability_method,
    calibration_date,
    certificate_number,
    validity_period,
    calibration_organization as calibration_institution,
    remarks,
    attachments,
    user_id,
    create_time,
    update_time
FROM tb_voyage_equipment 
WHERE user_id = :user_id
"""

result = db.session.execute(text(sql), {'user_id': user_id}).fetchall()

# 注意：循环中不要使用与“筛选参数”同名的局部变量（否则会覆盖外层查询条件）
all_equipment_list = []
for row in result:
    row_instrument_name = getattr(row, 'instrument_name', '')
    row_instrument_number = getattr(row, 'instrument_number', '')

    all_equipment_list.append({
        'id': row.id,
        'task_name': row.task_name,
        'category': row.category,
        'instrument_name': row_instrument_name,
        'instrument_number': row_instrument_number,
        'model': row.model,
        'traceability_method': row.traceability_method,
        'calibration_date': str(row.calibration_date) if row.calibration_date else None,
        'certificate_number': row.certificate_number,
        'validity_period': row.validity_period,
        'calibration_institution': row.calibration_institution,
        'remarks': row.remarks,
        'attachments': row.attachments,
        'user_id': row.user_id,
        'create_time': str(row.create_time) if row.create_time else None,
        'update_time': str(row.update_time) if row.update_time else None,
        'source_type': '航前' if row.source_type == 'pre_voyage' else '航中'
    })

# 应用筛选（全部在 Python 侧进行，保证语义一致）
filtered_list = all_equipment_list
if task_name:
    filtered_list = [e for e in filtered_list if task_name.lower() in e['task_name'].lower()]
if instrument_type:
    filtered_list = [e for e in filtered_list if instrument_type.lower() in e['category'].lower()]
if instrument_name:
    filtered_list = [e for e in filtered_list if instrument_name.lower() in e['instrument_name'].lower()]
if traceability:
    filtered_list = [e for e in filtered_list if traceability.lower() in (e['traceability_method'] or '').lower()]
if calibration_institution:
    filtered_list = [e for e in filtered_list if calibration_institution.lower() in (e['calibration_institution'] or '').lower()]

# 分页
total = len(filtered_list)
start_index = (page - 1) * page_size
end_index = start_index + page_size
equipment_list = filtered_list[start_index:end_index]
```

逐行说明：
- 读取 `page/page_size` 与各筛选参数；统一 `.strip()`，避免传入空格导致命中失败。
- 使用一段 `UNION ALL` SQL 联查两个表，并统一字段别名（如 `name -> instrument_name`），全部按 `user_id` 过滤，确保数据隔离。
- 查询后在 Python 里构建字典列表；特别注意：循环内使用 `row_instrument_name` 等变量名，避免覆盖外层同名的“筛选参数”。此前“只显示一条”的根因即为变量名覆盖导致再次被误筛选。
- 所有筛选在 Python 侧进行，语义与前端表单 1:1，对空值做兼容。
- 分页采用切片方式，返回 `list` 与 `total`。

---

### 二、前端：三个模块的 Excel 导出

#### 2.1 仪器设备管理（`src/views/system/equipment-management.vue`）

核心做法：
- 导出时重新以大页容量拉取一次数据（`page=1, page_size=100000`），确保“导出全部符合筛选条件的数据”，不受可视分页影响。
- 使用 `xlsx` 将 JSON 转为表格并保存。

代码片段：

```ts
import * as XLSX from 'xlsx'

const handleExport = async () => {
  const params = {
    page: 1,
    page_size: 100000,
    task_name: filterForm.task_name,
    instrument_type: filterForm.instrument_type,
    instrument_name: filterForm.instrument_name,
    traceability: filterForm.traceability,
    calibration_institution: filterForm.calibration_institution
  }

  const res = await fetchEquipmentManagementList(params)
  const rows = (res.data.list || []).map(row => ({
    '航次名称': row.task_name,
    '类别': row.category,
    '仪器(标准物质)名称': row.instrument_name,
    '编号': row.instrument_number,
    '型号': row.model,
    '量值溯源方式': row.traceability_method,
    '检定/校准日期': row.calibration_date,
    '证书编号': row.certificate_number,
    '有效期': row.validity_period,
    '检定/校准机构': row.calibration_institution,
    '备注': row.remarks,
    '数据来源': row.source_type
  }))

  const wb = XLSX.utils.book_new()
  const ws = XLSX.utils.json_to_sheet(rows)
  XLSX.utils.book_append_sheet(wb, ws, '仪器设备管理')
  XLSX.writeFile(wb, `仪器设备管理_${Date.now()}.xlsx`)
}
```

同理，已对“调查人员”（`investigation-personnel.vue`）与“任务单位”（`task-unit.vue`）分别实现同样的导出逻辑，只是字段映射不同。

#### 2.2 关键点
- 采用“再次请求 + 大分页”的方式导出，避免与页面分页耦合。
- 使用 `xlsx` 的 `json_to_sheet` 直接生成表格，简单稳定。
- 文件命名带上时间戳，防止覆盖。

---

### 三、表格横向滚动与固定操作列

目标：当列较多时，表格在宽度不足时出现横向滚动，且“操作”列固定于右侧。

实现要点：
- 为列提供合理的 `width`/`min-width`，总宽度超过容器触发横向滚动。
- 外层容器保持默认（Element Plus 会自动在列总宽超出时出现横向滚动）。
- 操作列使用 `fixed="right"` 固定。

参考（Element Plus 表格列配置）：

```vue
<el-table :data="tableData" border stripe>
  <el-table-column prop="task_name" label="航次名称" min-width="200" />
  <el-table-column prop="instrument_name" label="仪器名称" min-width="200" />
  <el-table-column prop="model" label="型号" width="120" />
  <!-- 其它列 ... -->
  <el-table-column label="操作" width="160" fixed="right" />
</el-table>
```

如需进一步“变窄行”的视觉表现，可在单元格内文本超长时使用省略样式：

```css
/* 仅示例，可按需放到 scoped 样式中 */
.ellipsis-cell {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

---

### 四、根因修复：为什么“只有一行数据”

现象：接口 200，但前端只看到 1 行。禁用分页后又能看到全部。

根因：后端在“构建行字典”的循环中使用了与筛选参数相同的变量名（例如 `instrument_name`），导致外层的“查询条件”被最后一条记录覆盖；随后又按这个被覆盖的条件进行二次过滤，自然只剩下符合“最后一条记录名称”的一行。

修复：将循环内字段改名（如 `row_instrument_name`），彻底避开与筛选参数同名。此后恢复了正常的筛选与分页，数据条数正确。

---

### 五、数据库建表脚本（示例，SQLAlchemy）

以下示例展示如何用 SQLAlchemy 定义并创建 `tb_equipment` 与 `tb_voyage_equipment` 两张表（与当前项目字段保持一致）：

```python
from datetime import datetime
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()

def create_app():
    app = Flask(__name__)
    app.config['SQLALCHEMY_DATABASE_URI'] = 'mysql+pymysql://user:pwd@127.0.0.1:3306/marine_survey_db?charset=utf8mb4'
    app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
    db.init_app(app)
    return app

class Equipment(db.Model):
    __tablename__ = 'tb_equipment'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    task_name = db.Column(db.String(255), nullable=False)
    category = db.Column(db.String(100), nullable=False)
    name = db.Column(db.String(255), nullable=False)
    number = db.Column(db.String(100), nullable=False)
    model = db.Column(db.String(100), nullable=False)
    traceability_method = db.Column(db.String(255))
    calibration_date = db.Column(db.String(45))
    certificate_number = db.Column(db.String(100))
    validity_period = db.Column(db.String(45))
    calibration_organization = db.Column(db.String(255))
    remarks = db.Column(db.Text)
    attachments = db.Column(db.Text)
    user_id = db.Column(db.Integer, nullable=False)
    create_time = db.Column(db.DateTime, default=datetime.now)
    update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)

class VoyageEquipment(db.Model):
    __tablename__ = 'tb_voyage_equipment'
    id = db.Column(db.Integer, primary_key=True, autoincrement=True)
    task_name = db.Column(db.String(255), nullable=False)
    category = db.Column(db.String(100), nullable=False)
    name = db.Column(db.String(255), nullable=False)
    number = db.Column(db.String(100), nullable=False)
    model = db.Column(db.String(100), nullable=False)
    traceability_method = db.Column(db.String(255))
    calibration_date = db.Column(db.String(45))
    certificate_number = db.Column(db.String(100))
    validity_period = db.Column(db.String(45))
    calibration_organization = db.Column(db.String(255))
    remarks = db.Column(db.Text)
    attachments = db.Column(db.Text)
    user_id = db.Column(db.Integer, nullable=False)
    create_time = db.Column(db.DateTime, default=datetime.now)
    update_time = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)

if __name__ == '__main__':
    app = create_app()
    with app.app_context():
        db.create_all()  # 第一次执行会在数据库中创建两张表
        print('tables created')
```

逐行要点：
- 统一使用 `name/number/traceability_method` 字段，与实际表结构一致，避免列名不匹配。
- 采用 `db.create_all()` 在首次部署时创建表结构；生产环境建议使用迁移工具（如 Alembic）进行版本化管理。

---

### 六、今日完成清单
- 修复“仪器设备管理”只显示一条数据：变量名覆盖筛选条件 → 已改名避冲突。
- 恢复并稳定筛选与分页逻辑（服务端筛选 + 切片分页）。
- 新增三处导出：
  - 仪器设备管理 导出 Excel
  - 调查人员 导出 Excel
  - 任务单位 导出 Excel
- 规范联查：使用 `UNION ALL`，并在 Python 侧统一字段名、进行筛选与分页。
- 表格横向滚动行为与操作列固定说明，提供可复用配置。

---

如需将本说明同步为英文或补充其它模块的导出/导入脚本，请在任务单中补充要求。


